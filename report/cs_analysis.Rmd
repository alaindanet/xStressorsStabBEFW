---
title: Simulation connectance richness
author: Alain Danet
output:
  bookdown::pdf_document2
---

```{r, echo = FALSE}
knitr::opts_chunk$set(
  cache = FALSE,
  collapse = TRUE,
  comment = "#>",
  #fig.dim = c(7, 7),
  fig.fullwidth = TRUE,
  fig.show = "hold",
  echo = FALSE,
  message = FALSE,
  warning = FALSE,
  results = TRUE,
  fig.path="figures/"
)
```

```{r, results = FALSE}
library(tidyverse)
library(magrittr)
library(cowplot)
library(here)
library(arrow)
library(piecewiseSEM)
library(semEff)
library(easystats)
library(glmmTMB)

mytheme <- theme_cowplot(font_size = 8) +
background_grid() +
theme(legend.position = "bottom")
theme_set(mytheme)
source(here::here("R", "network_metrics.R"))
source(here::here("R", "string_replacements.R"))
```

```{r}
sim_files <- list.files(here("res", "simCSZenrich"))
sim_list <- map(sim_files, function (x) {
  open_dataset(here::here("res", "simCSZenrich", x),
    format = "arrow") %>%
  collect()
})
```

```{r}
# TODO set extinction threshold in simulations
simZ_prep <- map_dfr(sim_list,
  function (x) {
    x %>%
      # Remove simulation that have failed to run
      filter(!is.na(richness)) %>%
      # Transform back interaction strength into matrices
      mutate(across(where(is.list), as.list)) %>%
      mutate(across(c(int_strength, max_int),
          ~map2(.x, S,
            function(y, rich) {
              matrix(y, nrow = rich)
            }
          )
      )
        ) %>%
      # Get matrix of alive species
      mutate(max_int_alive  = map2(max_int, bm_sp,
          function(mat, bm) {
            mask <- bm > 10^-6
            mat[mask, mask, drop = FALSE]
          }
        )
        )
  }
)
# Compute metrics of interest
simZ <- simZ_prep %>%
  mutate(
    persistence = richness / S,
    async = 1 / sync,
    stab_pop = 1 / avg_cv_sp,
    ct_alive = map_dbl(max_int_alive,
      ~ifelse(sum(.x) == 0, 0,
      sum(.x > 0) / ((ncol(.x))^2))),
    bm_sp_alive = map(bm_sp, ~.x[.x > 10^-6]),
    tlvl_alive = map2(tlvl, bm_sp, ~.x[.y > 10^-6]),
    max_tlvl_alive = map_dbl(tlvl_alive, max),
    w_avg_tlvl_alive = map2_dbl(tlvl_alive, bm_sp_alive, ~sum(.x * (.y / sum(.y)))),
    max_max_int_alive = map_dbl(max_int_alive,
      ~ifelse(length(.x[.x > 0]) == 0, 0, max(.x[.x > 0]))
      ),
    avg_max_int_alive = map_dbl(max_int_alive,
      ~ifelse(length(.x[.x > 0]) == 0, 0, mean(.x[.x > 0]))
      ),
    gini_max_int_alive = map_dbl(max_int_alive, ~gini(.x))
      )
simZ$tlvl_alive[[3]]
simZ$max_int_alive[[3]]
```


```{r, eval = FALSE}
colnames(sim)
unique(simZ$env_stoch)
summary(simZ$total_biomass)
summary(simZ$persistence)
summary(simZ$ct_alive)
summary(simZ$gini_max_int_alive)
```



```{r}
simZ %>%
  filter(rho == 0) %>%
  pivot_longer(
    c(stab_com, stab_pop, sync, total_biomass),
    names_to = "metric",
    values_to = "stab") %>%
  ggplot(aes(x = richness, y = stab, color = factor(env_stoch))) +
  geom_point() +
  facet_grid(rows = vars(metric), cols = vars(productivity), scales = "free_y") +
  labs(
    color = "Evironmental stochasticity",
    x = "Species richness",
    y = "Stability component"
  )
```

```{r}
simZ %>%
  filter(rho == 1) %>%
  mutate(stab_pop = 1/ avg_cv_sp) %>%
  pivot_longer(
    c(stab_com, stab_pop, sync, total_biomass),
    names_to = "metric",
    values_to = "stab") %>%
  ggplot(aes(x = richness, y = stab, color = factor(env_stoch))) +
  geom_point() +
  facet_grid(rows = vars(metric), cols = vars(productivity), scales = "free_y") +
  labs(
    color = "Evironmental stochasticity",
    x = "Species richness",
    y = "Stability component"
  )
```


```{r}
p_basic <- ~corrplot::corrplot(
  cor(simZ %>%
    filter(productivity == "enrichment") %>%
    select(c(S, richness, ct, Z, ct_alive, total_biomass, avg_max_int_alive,
        w_avg_tlvl_alive, max_tlvl_alive, rho, env_stoch, stab_com, avg_cv_sp,
        sync)),
    method = "spearman"),
  diag = FALSE, type = "upper"
)
p_enrich <- ~corrplot::corrplot(
  cor(simZ %>%
    filter(productivity == "basic") %>%
    select(c(S, richness, ct, Z, ct_alive, total_biomass, avg_max_int_alive,
        w_avg_tlvl_alive, max_tlvl_alive, rho, env_stoch, stab_com, avg_cv_sp,
        sync)),
    method = "spearman"),
  diag = FALSE, type = "upper"
)
plot_grid(
  ggdraw(p_basic),
  ggdraw(p_enrich),
  nrow = 2
)
```

- Main results:
  - Stability increases with richness but not connectance (no overall effect)
  - Richness increases stability by increasing maximum and average trophic
    level, but also by decreasing interaction strength and increasing asymetry
    in trophic interaction, and finally by increasing total biomass (I need to control for that).
  - Synchrony decreases with species richness, max and average trophic level but increases with
    average interaction strength and symetry of interaction distributions.
  - Population varibility decreases with species richness, average and maximum
    trophic level, asymetry of interaction strength but it is increased by
    average interaction strength
  - Same effects of food-web structure on both Synchrony and Population variability
    - Surpringly, as in Danet et al. (2021), connectance has little effect on
      temporal stability and its components!


# Covariation

```{r}
compute_rotated_pca <- function(.data = NULL, naxis = 2) {
  .data <- na.omit(.data)
  pca <- ade4::dudi.pca(as.data.frame(.data),
    scannf = FALSE, nf = naxis, center = TRUE, scale = TRUE
  )
  pca_rotated <- psych::principal(.data,
    rotate = "varimax", nfactors = naxis,
    scores = TRUE
  )

  return(list(normal = pca, rotated = pca_rotated))
}
```


```{r}
sim_sem <- simZ %>%
  filter(rho == 0) %>%
  mutate(across(c(async, sync, avg_cv_sp, stab_com, richness, avg_max_int_alive, gini_max_int), log, , .names = "log_{.col}")) %>%
  mutate(
    log1_avg_max_int_alive = log(avg_max_int_alive + 1),
    productivity_f = factor(productivity)

    ) %>%
  as.data.frame() %>%
  select(c(
      ct_alive, log_richness, max_tlvl_alive, Z,
      gini_max_int, avg_max_int_alive, log1_avg_max_int_alive, env_stoch,
      log_stab_com, log_sync, log_async, log_avg_cv_sp, productivity, productivity_f)
  )
scaled_sim_sem <- sim_sem %>%
  mutate(across(where(is.double), ~scale(.x)[,1]))
```

```{r}
pred_may <- "log1_avg_max_int_alive*log_richness*ct_alive*productivity + env_stoch"
rand <- "(1 | Z)"

mod_may_single <- lm(formula(str_replace_all(paste0("log_stab_com ~ ", pred_may), "\\*", "+")),
  scaled_sim_sem)
performance::check_collinearity(mod_may_single)
```

```{r}
mod_may <- glmmTMB(formula(paste0("log_stab_com ~ ", pred_may, " + ", rand)), scaled_sim_sem)

r2_nakagawa(mod_may)
par_mod_may <- parameters(mod_may)
plot(parameters(mod_may))
```

```{r}
mod_may_sync <- glmmTMB(formula(paste0("log_sync ~ ", pred_may, " + ", rand)),
  scaled_sim_sem)
r2_nakagawa(mod_may_sync)
plot(parameters(mod_may_sync))
```

```{r}
mod_may_cv_sp <- glmmTMB(formula(paste0("log_avg_cv_sp ~ ", pred_may, " + ", rand)),
  scaled_sim_sem)
r2_nakagawa(mod_may_cv_sp)
plot(parameters(mod_may_cv_sp))
```

## Rho model

- Should be include also the monotrophic communities ? I.e. Communities
  containing only plants?

```{r}
sim_rho <- simZ %>%
  #filter(ct_alive != 0) %>%
  mutate(across(c(async, sync, stab_pop, avg_cv_sp, stab_com, richness, avg_max_int_alive, gini_max_int), log, , .names = "log_{.col}")) %>%
  mutate(
    log1_avg_max_int_alive = log(avg_max_int_alive + 1),
    productivity_f = factor(productivity)

    ) %>%
  select(c(
      ct_alive, log_richness, max_tlvl_alive, Z, rho,
      gini_max_int, avg_max_int_alive, log1_avg_max_int_alive, env_stoch,
      log_stab_com, log_sync, log_async, log_stab_pop, log_avg_cv_sp, productivity, productivity_f,
      persistence)
  )
sim_rho_scaled <- sim_rho %>%
  mutate(across(where(is.double), ~scale(.x)[,1]))
```

```{r}
sim_rho %>%
  filter(ct_alive == 0, env_stoch == 0.5) %>%
  ggplot(aes(x = log_richness, y = log_stab_com)) +
  geom_point() +
  geom_smooth() +
  facet_grid(cols = vars(rho), rows = vars(productivity_f))
```

```{r}
pred_rho <- "log_richness +
ct_alive +
log1_avg_max_int_alive +
productivity +
rho +
I(rho^2) +
env_stoch +

log_richness:ct_alive +
log_richness:log1_avg_max_int_alive +
log_richness:productivity +
log_richness:rho +

log1_avg_max_int_alive:ct_alive +
log1_avg_max_int_alive:productivity +
log1_avg_max_int_alive:rho +

ct_alive:rho +
ct_alive:productivity +
rho:productivity +
I(rho^2):productivity +


log_richness:log1_avg_max_int_alive:ct_alive +
log_richness:log1_avg_max_int_alive:productivity +
log_richness:log1_avg_max_int_alive:rho +
log_richness:ct_alive:productivity +
log_richness:ct_alive:rho +
log_richness:rho:productivity +

log1_avg_max_int_alive:ct_alive:rho +
log1_avg_max_int_alive:ct_alive:productivity +
log1_avg_max_int_alive:rho:productivity +

ct_alive:rho:productivity"
rand <- "(1 | Z)"

mod_rho_single <- lm(formula(str_replace_all(paste0("log_stab_com ~ ", pred_rho), "(\\*|:)", "+")),
  sim_rho_scaled)
performance::check_collinearity(mod_rho_single)
```

```{r}
model2tibble <- function(x, response = NULL) {
  out <- parameters(x) %>%
    filter(Effects == "fixed", Parameter != "(Intercept)") %>%
    as_tibble() %>%
    janitor::clean_names() %>%
    mutate(
      response = var_replacement()[as.character(formula(x)[2])],
      parameter = str_replace_all(parameter, var_replacement()),
      count_int = str_count(parameter, ":"),
      effect_type = case_when(
        count_int == 0 ~ "single",
        count_int == 1 ~ "double",
        count_int == 2 ~ "triple",
        TRUE ~ "other"

      )
    ) %>%
    select(response, parameter:ci_high, effect_type)
    out
}
plot_effect_type <- function(x) {
  effect <- c("single", "double", "triple")
  p <- map(effect,
    function(y) {
      x %>%
        filter(effect_type == y) %>%
        arrange(coefficient) %>%
        ggplot(aes(
            y = reorder(parameter, -coefficient),
            x = coefficient,xmin = ci_low, xmax = ci_high,
            color = response
            )) +
        geom_vline(xintercept = 0, color = "black", linetype = "dashed", linewidth = 1.5) +
        geom_pointrange(position = position_dodge(width = 0.5)) +
        labs(x = "Standardized Coefficients")
    }
  )
  names(p) <- effect
  p
}
```

```{r}
mod_rho_scaled <- map(setNames(
    c("log_stab_com", "log_stab_pop", "log_async"),
    c("log_stab_com", "log_stab_pop", "log_async")
    ),
  function (x) {
    glmmTMB(formula(paste0(x, " ~ ", pred_rho, " + ", rand)),
      sim_rho_scaled)
  }
)
coef_mod_rho_scaled <- map_dfr(mod_rho_scaled, ~model2tibble(.x))
ti <- map_dfr(mod_rho_scaled, ~as.data.frame(r2_nakagawa(.x)), .id = "response") %>%
  mutate(response = var_replacement()[response])
p_mod_rho_scaled <- plot_effect_type(coef_mod_rho_scaled)
plot_grid(plotlist = p_mod_rho_scaled)
```

```{r}
mod_rho <- map(setNames(
    c("log_stab_com", "log_stab_pop", "log_async"),
    c("log_stab_com", "log_stab_pop", "log_async")
    ),
  function (x) {
    glmmTMB(formula(paste0(x, " ~ ", pred_rho, " + ", rand)),
      sim_rho)
  }
)
coef_mod_rho <- map_dfr(mod_rho, ~model2tibble(.x))
ti <- map_dfr(mod_rho, ~as.data.frame(r2_nakagawa(.x)), .id = "response") %>%
  mutate(response = var_replacement()[response])
p_mod_rho <- plot_effect_type(coef_mod_rho)
plot_grid(plotlist = p_mod_rho)
```

```{r, eval = FALSE}
sim_rho
```


```{r}
pred_list <- list(
  log_richness = c(log(1), log(5), log(10), log(20), log(30), log(50)),
  ct_alive = c(0, .10, .20),
  rho = c(0, .5, 1),
  log1_avg_max_int_alive = c(log(0 + 1), round(log(.81 + 1), 1), round(log(5.65 + 1), 1)),
  env_stoch = .5,
  productivity = c("basic", "enrichment"),
  Z = 100
)
pred_rho <- expand.grid(pred_list) %>%
  filter(
    !(log1_avg_max_int_alive == 0 & ct_alive != 0 | ct_alive == 0 & log1_avg_max_int_alive != 0)
  )

pred_rho$log_stab_com <- predict(mod_rho[["log_stab_com"]], newdata = pred_rho)

pred_rho %>%
  ggplot(aes(
      y = log_stab_com,
      x = log_richness,
      color = factor(ct_alive),
      linewidth = factor(log1_avg_max_int_alive)
      )) +
  geom_line() +
  facet_grid(
    rows = vars(rho),
    cols = vars(productivity)
  )
```




```{r, eval = FALSE}
mod_rho_tot <- glmmTMB(
  log_stab_com ~ log1_avg_max_int_alive*log_richness*ct_alive*rho*productivity +
    env_stoch + (1 | Z),
  sim_rho_scaled)
coef_mod_rho_tot <- model2tibble(mod_rho_tot)
coef_mod_rho_tot %>%
  ggplot(aes(y = parameter, x = coefficient, xmin = ci_low, xmax = ci_high)) +
  geom_pointrange() +
  labs(x = "Standardized Coefficients")
```

```{r}
sim_rho_pers <- simZ %>%
  mutate(across(c(S, ct, avg_max_int, gini_max_int), log, , .names = "log_{.col}")) %>%
  mutate(
    log1_avg_max_int = log(avg_max_int + 1),
    productivity_f = factor(productivity)
    ) %>%
  as.data.frame() %>%
  select(c(
      log_S, ct, max_tlvl, Z, rho,
      gini_max_int, avg_max_int, log1_avg_max_int, env_stoch,
      productivity, productivity_f,
      persistence)
  )
sim_rho_pers_scaled <- sim_rho_pers %>%
  mutate(across(where(is.double), ~scale(.x)[,1]))

pred_rho_pers <- "log1_avg_max_int * log_S * rho +
log1_avg_max_int * log_S * productivity +
log1_avg_max_int * log_S * ct +
log1_avg_max_int * ct * rho +
log1_avg_max_int * ct * rho +
log1_avg_max_int * ct * productivity +
log_S * rho * productivity +
log_S * ct * productivity +
log_S * ct * rho +
env_stoch"
rand <- "(1 | Z)"

mod_rho_pers <- glmmTMB(formula(paste0("persistence ~ ", pred_rho_pers, " + ", rand)),
  sim_rho_pers_scaled)

r2_nakagawa(mod_rho_pers)
plot(parameters(mod_rho_pers))
```

## Regression tree

```{r}
```

```{r, eval = FALSE}
library(rpart)
library(rpart.plot)
set.seed(123)
m1 <- rpart(
  formula = log_stab_com ~ .,
  data    = sim_rho %>%
    select(log_stab_com, log_richness, ct_alive, rho, env_stoch,
      gini_max_int, max_tlvl_alive, log1_avg_max_int_alive, productivity),
  method  = "anova"
  )
rpart.plot(m1)
```

```{r, eval=FALSE}
bagged_m1 <- bagging(
  formula = log_stab_com ~ .,
  data    = sim_rho %>%
    select(log_stab_com, log_richness, ct_alive, rho, env_stoch,
      gini_max_int, max_tlvl_alive, log1_avg_max_int_alive, productivity),
  coob    = TRUE
)
```

```{r}
library(ipred)
ctrl <- trainControl(method = "cv",  number = 10)

# CV bagged model
bagged_cv <- train(
  Sale_Price ~ .,
  data = ames_train,
  method = "treebag",
  trControl = ctrl,
  importance = TRUE
  )
```




# Effect of species richness


```{r}
sim_rich_prod <- simZ %>%
  filter(
    Z == 100,
    env_stoch == .5,
    rho %in% c(0, 1)
  )
```

```{r}
p_sim_rich_prod <- sim_rich_prod %>%
  mutate(stab_pop = 1/ avg_cv_sp) %>%
  pivot_longer(
    c(stab_com, stab_pop, sync),
    names_to = "metric",
    values_to = "stab") %>%
  mutate(
    metric = var_replacement()[metric],
    rho = rho_replacement()[as.character(rho)]
  ) %>%
  ggplot(aes(x = richness, y = stab, color = factor(productivity))) +
  geom_point(alpha = .1, shape = 20) +
  geom_smooth() +
  facet_grid(rows = vars(metric), cols = vars(rho), scales = "free_y") +
  labs(
    color = "Productivity",
    x = "Species richness",
    y = "Stability component"
  ) +
  scale_x_continuous(
    sec.axis = sec_axis(~ . ,
      name = "Response diversity",
      breaks = NULL,
      labels = NULL)
  )
ggsave(
  filename = here::here("fig", "stability_rich.pdf"),
  p_sim_rich_prod,
  scale = 1.8,
  width = 88,
  height = 88 * .6,
  units = "mm"
)
```

