---
title: "Target Markdown"
output: html_document
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

Target Markdown is a powerful R Markdown interface for reproducible analysis
pipelines, and the chapter at https://books.ropensci.org/targets/markdown.html
walks through it in detail. This R Markdown report the example from the chapter.
Try it out in both interactive and non-interactive modes, either by running the
code chunks in different ways or setting the `tar_interactive` chunk option.

# Packages

The example requires several R packages, and `targets` must be version 0.5.0.9000 or above.

```{r, eval = FALSE}
install.packages(c("biglm", "dplyr", "ggplot2", "readr", "targets", "tidyr"))
```

# Setup

If you are using old versions of `targets` (<= 0.7.0) and/or `knitr` (<= 1.33), you will need to load the `targets` package in the R Markdown document in order for Target Markdown code chunks to work.

```{r}
library(targets)
```

Near the top of the document, you may also wish to remove the `_targets_r` directory previously written by non-interactive runs of the report. Otherwise, your pipeline may contain superfluous targets.

```{r}
library(targets)
tar_unscript()
```

# Globals

We first define some global options/functions common to all targets. The function below plots a histogram of ozone concentrations, and our histogram target will need it.

```{targets example-globals, tar_globals = TRUE}
options(tidyverse.quiet = TRUE)
tar_option_set(packages = c("tidyverse", "magrittr", "cowplot", "here", "arrow", "piecewiseSEM", "semEff", "easystats", "glmmTMB"))
source(here::here("R", "network_metrics.R"))
source(here::here("R", "string_replacements.R"))
source(here::here("R", "stability_decomposition.R"))
source(here::here("R", "model_helpers.R"))
```

# Targets

Our first target borrows the `airquality` dataset built into base R.

```{targets raw-data}
list(
  tar_target(sim_list, {
    sim_files <- list.files(here("res", "simCSZenrich"))
    map(sim_files,
      function (x) {
        open_dataset(here::here("res", "simCSZenrich", x),
          format = "arrow") %>%
        collect()
      })
}
    ),
  tar_target(simZ_prep,
    map_dfr(sim_list,
      function (x) {
        x %>%
          # Remove simulation that have failed to run
          filter(!is.na(richness)) %>%
          # Transform back interaction strength into matrices
          mutate(across(where(is.list), as.list)) %>%
          mutate(across(c(int_strength, max_int),
              ~map2(.x, S,
                function(y, rich) {
                  matrix(y, nrow = rich)
                }
              )
          )
            ) %>%
          # Get matrix of alive species
          mutate(max_int_alive  = map2(max_int, bm_sp,
              function(mat, bm) {
                mask <- bm > 10^-6
                mat[mask, mask, drop = FALSE]
              }
            )
          )
      }
    )
    ),
  tar_target(simZ,
    simZ_prep %>%
      mutate(
        persistence = richness / S,
        async = 1 / sync,
        stab_pop = 1 / avg_cv_sp,
        ct_alive = map_dbl(max_int_alive,
          ~ifelse(sum(.x) == 0, 0,
            sum(.x > 0) / ((ncol(.x))^2))),
        bm_sp_alive = map(bm_sp, ~.x[.x > 10^-6]),
        tlvl_alive = map2(tlvl, bm_sp, ~.x[.y > 10^-6]),
        max_tlvl_alive = map_dbl(tlvl_alive, max),
        w_avg_tlvl_alive = map2_dbl(tlvl_alive, bm_sp_alive,
          ~sum(.x * (.y / sum(.y)))
          ),
        max_max_int_alive = map_dbl(max_int_alive,
          ~ifelse(length(.x[.x > 0]) == 0, 0, max(.x[.x > 0]))
          ),
        avg_max_int_alive = map_dbl(max_int_alive,
          ~ifelse(length(.x[.x > 0]) == 0, 0, mean(.x[.x > 0]))
          ),
        sd_max_int_alive = map_dbl(max_int_alive,
          ~ifelse(length(.x[.x > 0]) <= 1, 0, sd(.x[.x > 0]))
          ),
        cv_max_int_alive = sd_max_int_alive / avg_max_int_alive,
        inv_sd_max_int_alive = 1 / sd_max_int_alive,
        gini_max_int_alive = map_dbl(max_int_alive,
          ~ifelse(length(.x[.x > 0]) == 0, 0, gini(.x[.x > 0])))
      )
  )
)
```

```{targets raw_sim}
list(
  tar_target(var_param_sim, c("rep", "productivity", "S", "ct", "rho", "env_stoch", "Z")),
  tar_target(sim_files, list.files(here::here("res", "simCSZenrich2/simCSZenrich2"))),
  tar_target(sim_ts,
    map_dfr(sim_files,
      function (x) {
        open_dataset(here::here("res", "simCSZenrich2/simCSZenrich2", x),
          format = "arrow") %>%
        collect() %>%
      filter(!is.na(richness)) %>%
      select(c(var_param_sim, "species", "stoch")) %>%
      # Transform back interaction strength into matrices
      mutate(across(where(is.list), as.list)) %>%
      mutate(
        stoch_d = map2(species, stoch, function(bm, d_stoch) {
          .1 * bm * exp(d_stoch)
          }),
        species = map(species, ~matrix(.x, nrow = 100)),
        stoch = map(stoch, ~matrix(.x, nrow = 100)),
        stoch_d = map(stoch_d, ~matrix(.x, nrow = 100)),
        cpe = map_dbl(species, compensatory_effect),
        cpe_env = map_dbl(stoch_d, compensatory_effect),
        cpe_int = cpe / cpe_env,
        stab_com = map_dbl(species, community_stability),
        pop_stab = map_dbl(species, population_stability),
        async = map_dbl(species, asynchrony),
        sae = map(species, statistical_averaging_effect)
      )
      })
  ),
  tar_target(sim_stab, sim_ts %>% select(-species, -stoch_d, -stoch)),
  tar_target(sim_prep,
map_dfr(sim_files,
      function (x) {
        open_dataset(here::here("res", "simCSZenrich2/simCSZenrich2", x),
          format = "arrow") %>%
        collect() %>%
      filter(!is.na(richness)) %>%
      select(-species, -stoch, -A) %>%
      # Transform back interaction strength into matrices
      mutate(across(where(is.list), as.list)) %>%
      mutate(across(c(int_strength, max_int),
          ~map2(.x, S,
            function(y, rich) {
              matrix(y, nrow = rich)
            }
          )
      )
        ) %>%
      # Get matrix of alive species
      mutate(max_int_alive  = map2(max_int, bm_sp,
          function(mat, bm) {
            mask <- bm > 10^-6
            mat[mask, mask, drop = FALSE]
          }
        )
      )
      }

    )),
  tar_target(sim,
    sim_prep %>%
      mutate(
        persistence = richness / S,
        async = 1 / sync,
        stab_pop = 1 / avg_cv_sp,
        ct_alive = map_dbl(max_int_alive,
          ~ifelse(sum(.x) == 0, 0,
            sum(.x > 0) / ((ncol(.x))^2))),
        bm_sp_alive = map(bm_sp, ~.x[.x > 10^-6]),
        tlvl_alive = map2(tlvl, bm_sp, ~.x[.y > 10^-6]),
        max_tlvl_alive = map_dbl(tlvl_alive, max),
        w_avg_tlvl_alive = map2_dbl(tlvl_alive, bm_sp_alive,
          ~sum(.x * (.y / sum(.y)))
          ),
        max_max_int_alive = map_dbl(max_int_alive,
          ~ifelse(length(.x[.x > 0]) == 0, 0, max(.x[.x > 0]))
          ),
        avg_max_int_alive = map_dbl(max_int_alive,
          ~ifelse(length(.x[.x > 0]) == 0, 0, mean(.x[.x > 0]))
          ),
        sd_max_int_alive = map_dbl(max_int_alive,
          ~ifelse(length(.x[.x > 0]) <= 1, 0, sd(.x[.x > 0]))
          ),
        cv_max_int_alive = sd_max_int_alive / avg_max_int_alive,
        inv_sd_max_int_alive = 1 / sd_max_int_alive,
        gini_max_int_alive = map_dbl(max_int_alive,
          ~ifelse(length(.x[.x > 0]) == 0, 0, gini(.x[.x > 0]))),
        avg_omnivory = map_dbl(omnivory, mean),
        disconnected_prod = map_lgl(max_int_alive,
        ~any(colSums(.x) == 0 & rowSums(.x) == 0))
      ) %>%
    select(!where(is.list))
  )
)
```


```{targets sim_rho, tar_simple = TRUE}
simZ %>%
  filter(ct_alive != 0, avg_max_int_alive != 0) %>%
  mutate(across(c(async, sync, stab_pop, avg_cv_sp, stab_com, richness, avg_max_int_alive, gini_max_int), log, , .names = "log_{.col}")) %>%
  mutate(
    log1_avg_max_int_alive = log(avg_max_int_alive + 1),
    productivity_f = factor(productivity)
    ) %>%
  select(c(
      ct_alive, log_richness, max_tlvl_alive, Z, rho,
      gini_max_int, avg_max_int_alive, log1_avg_max_int_alive, env_stoch,
      log_stab_com, log_sync, log_async, log_stab_pop, log_avg_cv_sp, productivity, productivity_f,
      persistence)
  )
```

```{targets sim_rho_scaled, tar_simple = TRUE}
sim_rho %>%
  mutate(across(where(is.double), ~scale(.x)[,1]))
```

```{targets rho_model}
list(
  tar_target(formula_fixed_rho, "log_richness +
    ct_alive +
    log1_avg_max_int_alive +
    productivity +
    rho +
    I(rho^2) +
    env_stoch +

    log_richness:ct_alive +
    log_richness:log1_avg_max_int_alive +
    log_richness:productivity +
    log_richness:rho +

    log1_avg_max_int_alive:ct_alive +
    log1_avg_max_int_alive:productivity +
    log1_avg_max_int_alive:rho +

    ct_alive:rho +
    ct_alive:productivity +
    rho:productivity +
    I(rho^2):productivity +


    log_richness:log1_avg_max_int_alive:ct_alive +
    log_richness:log1_avg_max_int_alive:productivity +
    log_richness:log1_avg_max_int_alive:rho +
    log_richness:ct_alive:productivity +
    log_richness:ct_alive:rho +
    log_richness:rho:productivity +

    log1_avg_max_int_alive:ct_alive:rho +
    log1_avg_max_int_alive:ct_alive:productivity +
    log1_avg_max_int_alive:rho:productivity +

    ct_alive:rho:productivity"
    ),
  tar_target(formula_rand_rho, "(1 | Z)"),
  tar_target(mod_rho, map(setNames(
    c("log_stab_com", "log_stab_pop", "log_async"),
    c("log_stab_com", "log_stab_pop", "log_async")
    ),
  function (x) {
    glmmTMB(formula(paste0(x, " ~ ", formula_fixed_rho, " + ", formula_rand_rho)),
      sim_rho)
  }
  )),
  tar_target(coef_mod_rho, map_dfr(mod_rho, ~model2tibble(.x))),
  tar_target(r2_mod_rho, map_dfr(mod_rho, ~as.data.frame(r2_nakagawa(.x)), .id = "response") %>%
  mutate(response = var_replacement()[response])),
  tar_target(p_mod_rho, plot_effect_type(coef_mod_rho)),
  tar_target(mod_rho_scaled, map(setNames(
    c("log_stab_com", "log_stab_pop", "log_async"),
    c("log_stab_com", "log_stab_pop", "log_async")
    ),
  function (x) {
    glmmTMB(formula(paste0(x, " ~ ", formula_fixed_rho, " + ", formula_rand_rho)),
      sim_rho_scaled)
  }
)
    ),
  tar_target(coef_mod_rho_scaled, map_dfr(mod_rho_scaled, ~model2tibble(.x))),
  tar_target(r2_mod_rho_scaled,
    map_dfr(mod_rho_scaled, ~as.data.frame(r2_nakagawa(.x)), .id = "response") %>%
      mutate(response = var_replacement()[response])),
  tar_target(colin_rho, performance::check_collinearity(lm(formula(str_replace_all(paste0("log_stab_com ~ ", formula_fixed_rho), "(\\*|:)", "+")),
  sim_rho_scaled))),
    tar_target(p_mod_rho_scaled, plot_effect_type(coef_mod_rho_scaled))
)
```

```{targets pred_rho}
tar_target(pred_rho,
  {
  pred_rho <- list(
    log_richness = c(log(1), log(5), log(10), log(20), log(30), log(50)),
    ct_alive = c(.05, .10, .40),
    rho = c(0, .5, 1),
    log1_avg_max_int_alive = c(log(0.2 + 1), round(log(.81 + 1), 1), round(log(5.65 + 1), 1)),
    env_stoch = .5,
    productivity = c("basic", "enrichment"),
    Z = 100
    ) %>% expand.grid() %>%
  filter(
    !(log1_avg_max_int_alive == 0 & ct_alive != 0 | ct_alive == 0 & log1_avg_max_int_alive != 0)
  )
  pred_rho$log_stab_com <- predict(mod_rho[["log_stab_com"]], newdata = pred_rho)
  pred_rho
  }
)
```




# Pipeline

If you ran all the `{targets}` chunks in non-interactive mode, then your R scripts are set up to run the pipeline.

```{r}
tar_make()
```

# Output

You can retrieve results from the `_targets/` data store using `tar_read()` or `tar_load()`.

```{r, message = FALSE}
library(tidyverse)
library(magrittr)
library(cowplot)
library(here)
library(arrow)
library(piecewiseSEM)
library(semEff)
library(easystats)
library(glmmTMB)
```

```{r}
tar_read(sim_ts)
```


```{r}
tar_read(sim_rho)
```

The `targets` dependency graph helps your readers understand the steps of your pipeline at a high level.

```{r}
tar_visnetwork()
```

At this point, you can go back and run `{targets}` chunks in interactive mode without interfering with the code or data of the non-interactive pipeline.
